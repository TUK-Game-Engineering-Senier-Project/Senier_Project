-----<변환 파이프라인>-----

# [1차시]

모델 좌표 -> [월드 변환 (회전->평행 이동) -> 카메라 변환 -> 투영 변환 -> 화면 변환] -> 화면 좌표

카메라
:: 게임 월드를 보기 위한 가상의 카메라, 일반적으로 [플레이어 캐릭터]에 부착되어 있음
:: 위치 (Position) / 방향 (Viewing Direction) / 화각 (FOV - Field Of View)
:: 카메라 좌표계 : [카메라를 중심]으로 한 상대적인 [게임 월드] 좌표계
:: 카메라의 움직임은 [화면상의 객체]와 [반대]로 이동

카메라 변환
:: 카메라를 [월드 좌표계의 원점]으로 이동하여 [같은 평행이동]을 [모든 객체]에 적용
:: 카메라 좌표계의 [축]이 [월드 좌표계의 축]과 [일치하도록 회전] 후 [같은 회전]을 [모든 객체]에 적용

# [2차시]

원근 투영 변환
:: [3D Mesh]를 [2D 화면]에 그리는 방법
:: [카메라 기준] [멀리] 있는 객체는 [작게], [가까이] 있는 객체는 [크게] 그린다.
:: 투영 좌표계 : [카메라 중심선]을 기준으로 상하좌우를 표현한 [하나의 좌표계]
:: [카메라 범위 내]에 있는 [오브젝트]만 보이게 된다.

화면 좌표 변환
:: [투영 좌표 공간]을 [화면]으로 [매핑]
:: 뷰포트 : [투영 좌표 공간]이 [매핑]될 [화면 영역]
:: [투영 사각형]이 [가운데]를 (0,0)으로 하는 반면, [뷰포트]는 [좌상단]을 (0,0)으로 한다.

벡터
:: [점] 또는 [방향과 크기] - 반드시 한 점인 것은 아니다.
:: 영벡터 : 크기가 0이고 방향이 없는 벡터
:: [크기]와 [방향]이 [같으면] [같은 벡터]이다.
:: 벡터 정규화 : [크기]가 [1이 아닌] 벡터를 [크기가 1인 [단위 벡터]]로 만드는 것
:: [방향 벡터]는 [단위 벡터]이다.

행렬
:: 행 (Row)와 열 (Column)으로 구성된 [표]
:: [DirectX]에서는 [행 우선 행렬]을 사용한다.
:: 3D 벡터는 [1 * 3] 행렬이다.
:: 오브젝트의 [월드 좌표계]에서의 [위치 및 방향]을 나타내기 위해 [행렬을 사용]한다.

월드 변환 행렬
:: [월드 좌표계]에서 객체의 [위치와 방향]을 포함한다.
:: [방향]은 객체의 [로컬 좌표축] (Right / Up / Look)을 말한다.
:: [월드 좌표 정점]은 [모델 좌표 정점]에 [월드 변환 행렬]을 곱한 값이다.

# [3차시]

벡터의 외적
:: 두 벡터의 [외적] 결과는 [두 벡터]에 [각각 수직]인 벡터이다.
:: 법선 벡터 : [방향]을 나타내는 [단위 벡터]이자 [다각형의 면]에 [수직]인 벡터

벡터의 내적
:: 두 벡터의 [내적] 결과는 [실수]이다.
:: [내적] 연산시 [시작점]이 [같아야] 한다.
:: 직교 투영, 반사 벡터, 굴절 벡터 등에 쓰인다.

평면
:: 3D 공간에서 [무한히 확장]하는 [면]
:: [법선 벡터]가 [원점]에서 [멀어지면] [원점이 평면 뒤]에 있으며 [원점에서 평면까지의 거리]가 [음수]이다.
:: [법선 벡터]가 [원점]으로 [가까워지면] [원점이 평면 앞]에 있으며 [원점에서 평면까지의 거리]가 [양수]이다.
:: [평면의 법선 벡터]와 [원점에서 평면 위 점까지의 벡터]를 [내적]하여 [원점과 평면까지의 거리]를 구할 수 있다.

# [4차시]

은면 제거 : 다각형이 [카메라를 향하지 않을 때] 다각형의 [정점 변환]을 피하는 것

행렬
:: 역행렬 : 어떤 변환의 [역변환]
:: 벡터에 [행렬을 곱]하는 것은 [벡터를 변환]하는 것이다.
:: 아핀 변환 : 원본 벡터 * 회전 변환 + 평행 이동 변환
:: 4차원 벡터 (x, y, z, 1)은 3차원 벡터 (x, y, z)와 동일하다.

-----<Direct3D 그래픽스 파이프라인>-----

# [1차시]

Direct3D 12 렌더링 파이프라인
:: [1] 입력 조립기 -> 정점 쉐이더* -> 헐 쉐이더* -> 테셀레이터 -> 도메인 쉐이더* -> 기하 쉐이더* -> [2] 래스터라이저 -> 픽셀 쉐이더* -> [3] 출력 병합기
:: [GPU]를 사용하여 [리소스]를 [2D 이미지로 렌더링]하는 과정
:: 고정 프로그램 단계 : Direct3D [자체적으로 처리]
:: 프로그램 가능 단계 : [응용 프로그램]에서 [쉐이더 프로그램]을 통해 제공 (위의 별* 붙은 단계들)

Direct3D 디바이스 <- GPU
:: 상태 기계 (State Machine)
:: [리소스]를 화면에 출력하기 위해서는 [뷰]라는 형태로 [변환]이 필요
:: Render Target에 [렌더링의 결과]로 얻어진 [실제 이미지]를 출력
:: Depth / Stensil Buffer에 [렌더링에 필요한 정보]를 [버퍼]에 출력

[1] 입력-조립 단계 : 고정 함수 단계
:: 정점 버퍼의 [정점 데이터]를 다음 단계에서 사용할 [프리미티브]로 조립
:: 시스템 생성값 ([시멘틱] 문자열)을 추가

[2] 레스터라이저 단계
:: [프리미티브] (벡터 정보)를 [래스터 이미지]로 변환
:: [정점]은 [픽셀]로 변환, [내부 점]들은 [보간]을 거쳐 [픽셀]로 변환
:: [원근 투영] -> [카메라 절두체]를 [벗어나는 점들]을 [클리핑] -> [프리미티브]를 [2차원 뷰포트]로 매핑 -> 모든 픽셀에 [픽셀 쉐이더] 호출

[3] 출력-병합 단계
:: 픽셀의 [색상을 생성]하여 [렌더 타겟]으로 출력
:: 깊이-스탠실 검사 : 픽셀이 [그려져야 하는지]를 검사, [스탠실이 없거나], [파이프라인에 연결이 안 되어]있다면 [언제나 성공]한다.
:: 깊이-스탠실 검사시 [하나]의 깊이-스탠실 [버퍼]만 활성화된다.
:: [블렌딩]을 통하여 [렌더 타겟]의 픽셀 색상과 [픽셀 쉐이더] 출력 색상을 [결합]하여 [최종 픽셀 색상]을 결정한다.

# [2차시]

쉐이더 단계
:: 메모리 리소스 : 상수 버퍼, 텍스쳐, 버퍼
:: 모델 4 기준 16개의 샘플러, 128개의 텍스쳐 및 버퍼, 16개의 상수 버퍼를 연결할 수 있다.

정점-쉐이더 단계
:: [프리미티브]의 [각 정점]에 대한 [연산]을 수행한다.
:: 정점 쉐이더는 [한 정점당 1번] 호출되며, [1개]의 [출력 정점]을 생성
:: [항상 수행되는 단계]이다. (변환이 필요하지 않은 경우에도 필수)
:: [텍스쳐] 불러오기와 [샘플링] 연산을 수행할 수 있다.

픽셀-쉐이더 단계
:: [각 픽셀]의 데이터 (색상 등)를 생성한다.
:: [각 픽셀]에 대하여 [1번] 호출된다.
:: [픽셀]의 정점 속성은 [프리미티브]의 정점 속성으로부터 [보간]된다.
:: [픽셀을 버리면] [색상]과 [깊이값]이 [출력되지 않는다].

Direct3D 프로그래밍 환경 설정
:: Windows 10 SDK / Visual Studio / Direct3D 12 API
:: #include <d3d12,h>
:: DirectX Tool Kit / DirectXTex / DirectXMesh / DirectXMath / UVAtlas

프레임 버퍼
:: [모니터로 출력]되어야 하는 [비디오 메모리] 영역
:: 프레임 레이트 : [1초]동안 출력되는 [평균 프레임 수]

색상
:: A(투명도), R, G, B
:: [0~255] 사이에서 [0.0f~1.0f] 사이로 변환됨
:: XMCOLOR : 각 요소가 8비트. 총합 [32비트]
:: XMVECTOR : 각 요소가 32비트, 총합 [128비트]
:: 색상을 [벡터(XMVECTOR)로 취급]하여 요소별 실수 연산

-----<Direct3D 디바이스>-----

# [1차시]

이중 버퍼링
:: 전면 버퍼, 후면 버퍼 : 전면 버퍼는 [디스플레이]와 [직접 연결]되어 [현재 출력하는] 이미지 / 후면 버퍼는 [다음에 출력할] 이미지
:: 스왑 체인 : [순차적]으로 [연결]된 [프레임 버퍼들]의 [집합]
:: 프레젠테이션 : [후면 버퍼]의 내용을 [전면 버퍼]로 [옮기는 것]
:: 플리핑 : [하드웨어]적 방법으로 [전면 버퍼와 후면 버퍼]를 [교체]
:: 블리트 : [버퍼의 내용]을 [복사]

COM 객체 : Component Object Model. [DLL] 형태로 제공
:: [모든 Direct3D 객체]는 [COM 객체]이다.
:: 객체의 [내부]는 [비공개], [호출]용 [메소드 함수]만을 제공한다.
:: 일반적인 C++ 객체와 유사하게 사용하되 [노출된 메소드]를 호출할 수만 있다.

IUnknown 인터페이스 : 모든 COM 인터페이스는 여기서 파생되었다.
:: IUnknown::AddRef : 참조 카운터를 1 증가 ([메소드를 호출]한 [객체]가 [이 객체]를 [사용함])
:: IUnknown::Release : 참조 카운터를 1 감소 ([메소드를 호출]한 [객체]가 [이 객체]를 [사용하지 않음])
:: IUnknown::QueryInterface : 어떤 인터페이스를 제공하는가를 묻는다.

COM 객체의 생성 및 소멸
:: [참조 카운터]가 [0]이 되면 [자동으로 소멸]한다.
:: new나 delete를 [사용하지 않]는다. delete의 역할을 [Release()] 호출로 대체한다.
:: COM 객체의 [인터페이스 포인터]를 [다른 객체]로 복사할 때 [AddRef()]를 호출한다.
:: 생성시 : [포인터 변수] 선언 및 [포인터 변수의 주소]를 넘김

GUID : Globally Unique IDentifier
:: [인터페이스 클래스 식별자] 128비트 정수 문자열
:: [guidgen.exe] 또는 [도구 -> GUID 만들기]로 생성
:: __uuidof(expression) : [GUID를 반환]하는 연산자
:: IID (Interface Identifier) : [인터페이스]를 [구별]하기 위한 [GUID]
:: ComPtr 클래스 : 인터페이스 포인터의 [소멸자]에서 [Release()를 호출]하는 [스마트 포인터]

DXGI : DirectX Graphics Infrastructure
:: [DirectX 그래픽]을 위한 [기본적, 공통적] [프레임워크]
:: 새로운 그래픽 라이브러리가 나와도 [변하지 않는 부분]

# [2차시]

다중 샘플링
:: [모든 Direct3D 12 디바이스]는 [모든 DXGI]에 대하여 4X [다중 샘플링]을 [지원]한다.
:: [시간이 많이] 걸리므로 [하드웨어적]으로 [처리를 권장]
:: 계단 현상 : 픽셀 크기의 최소치 때문에 발생
:: 슈퍼 샘플링, 다중 샘플링 등은 [계단 현상]을 제거하기 위해 탄생함

샘플링
:: 슈퍼 샘플링 : [후면 버퍼, 깊이 버퍼] 해상도를 화면 크기보다 [2*2배] 크게 렌더링 
:: [슈퍼 샘플링]시 [렌더링 시간]과 [테스트하는 픽셀 수]가 [4배]가 된다.
:: 다중 샘플링 : 기본적인 [방법은 슈퍼 샘플링과 동일]
:: [다중 샘플링]시 [화면의 픽셀]마다 [1번만 색상을 계산]한다.
:: [다중 샘플링]시 깊이, 스텐실 검사로 결정되는 [가시성] 및 다각형에 [포함 여부]를 가지고 [서브 픽셀]의 [색상]을 [결정]한다.

# [3차시]

화면 전환
:: [DXGI]는 [Alt+Enter] 키로 [전체 화면 모드 <-> 윈도우 모드] 전환을 제공한다.
:: 수동적으로 켜거나 끌 수 있다.
:: [클라이언트 영역]의 [크기]가 [변경]되면 [WM_SIZE] 메시지를 발생시킨다.
:: [전체 화면 모드]에서 DWM (Desktop Window Manager)는 비활성화된다.
:: [전체 화면 모드]에서 [DXGI]는 [플립]을 수행할 수 있으며, [블리트]보다 성능이 좋다.
:: [플립]은 [후면 버퍼]와 [전면 버퍼]가 [같은 크기 및 형식]일 때 가능하다. - 일치하지 않으면 대신 [블리트]를 수행한다.
:: [윈도우 모드]일 때는 [윈도우 크기]를 변경한다.
:: [전체 화면 모드]일 때는 [바탕화면 모드]를 변경한다.

명령 큐, 명령 리스트
:: [GPU]는 [명령 큐]를 가지고 있으며, 큐의 [GPU 명령]들을 [순차적으로 수행]한다.

# [4차시]

CD3DX12_CPU_DESCRIPTOR_HANDLE / CD3DX12_GPU_DESCRIPTOR_HANDLE
:: DirectX 3D를 C++ 형태로 사용할 수 있게 만든 CPU / GPU 핸들

쉐이더 리소스
:: 리소스 : [렌더링 과정] 동안 [GPU가 사용]하는 [데이터]로 [비디오 메모리]에 저장된다.
:: 후면 버퍼, 텍스쳐, 버퍼, 파이프라인 등등

리소스 뷰 : [파이프라인]에 [리소스]를 [연결할 때] [뷰]를 [통하여 연결됨]
:: 서술자(뷰) : [하나]의 [리소스]에 대한 [정보를 포함]하는 [자료 구조 객체]
:: 렌더 타겟 뷰, 깊이 스텐실 뷰 등등

ID3D12DescriptorHeap : [리소스 서술자들]을 저장하는 [연속적]인 [메모리 배열]
ID3D12Device::CreateRenderTargetView : [렌더 타겟 뷰]를 생성한다.
ID3D12Device::CreateDepthStencilView : [깊이-스텐실 버퍼 뷰]를 생성한다,

깊이 버퍼 : 카메라로부터 [z 깊이가 작은 값]을 가져와 화면에서 [보이는 해당 부분]의 [좌표와 색상]을 표시한다.

# [5차시]

리소스 : [가상 메모리]에 생성된다.
:: [GPU]가 [리소스를 사용]하기 위해서는 [물리적 메모리]로 [매핑]되어야 한다.

[렌더 타겟 버퍼]와 뷰 [생성]
-> [깊이-스텐실 버퍼]와 뷰 [생성]
-> 렌더 타겟 버퍼와 깊이-스텐실 버퍼 [초기화]
-> [렌더 타겟]과 [깊이-스텐실 버퍼]를 [파이프라인에 연결] (CPU 서술자 설정)
:: [렌더 타겟]과 [깊이-스텐실 버퍼]의 [크기가 같아야] 한다.
:: [모든] [렌더 타겟]의 [크기가 같아야] 한다.

[래스터라이저] 단계 설정
:: 뷰포트 설정 / 시저 사각형 설정
:: [뷰포트] : 렌더 타겟 (후면 버퍼) 영역 구조체
:: [Reset]될 때마다 [뷰포트]를 [재설정] / [모든] [뷰포트]를 [동시]에 [설정]해야 한다.
:: [시저 사각형] : [렌더링]에서 [제거되지 '않을'] 영역
:: [모든] [시저 사각형]을 [동시]에 [설정]해야 한다.
:: [시저 사각형]에 포함되지 [않은] 영역은 [렌더링시] [제거]된다.

-----<Direct3D 그래픽스 파이프라인>-----

# [3차시]

[래스터라이저] 단계 준비
:: 래스터라이저 [상태 생성]
-> 래스터라이저 상태를 [파이프라인 상태]의 [RS 단계]에 연결
:: [보수적] 래스터라이제이션 : [프리미티브]에 [조금이라도 걸치는] [모든 픽셀]을 래스터라이제이션한다.
:: [표준적] 래스터라이제이션 : [샘플링]을 사용하는 방법

게임 프레임워크
:: 프레임워크 : 디바이스, 스왑 체인, 렌더 타켓, 명령 리스트, 타이머
:: [프레임워크]에서 [CScene] [포인터]를 [CScene]에 연결
:: [게임 오브젝트] [포인터]는 각 [게임 오브젝트]에 연결됨
:: [게임 오브젝트]는 [메쉬]와 [쉐이더 객체] 포인터를 포함함

게임 프레임워크 상세
:: BuildObjects() : 오브젝트 구성
:: Tick() : 타이머
:: ProcessInput() : 입력 처리
:: AnimateObjects() : 오브젝트 이동 처리
:: Render() : 렌더링
:: 프레임워크의 AnimateObjects()는 [CScene]의 AnimateObjects(), [게임 객체]의 Animate()로 연결되어 처리된다.
:: 프레임워크의 Render()는 [CScene]의 Render(), [게임 객체]의 Render(), [메쉬]의 Render()로 연결되어
[Direct3D]의 Draw()로 처리가 되고 [쉐이더 코드]로 CreateShader()되어 [CScene]의 BuildObjects()로 연결된다.

쉐이더 컴파일
:: [응용 프로그램]에서 컴파일 : [정점 쉐이더]와 [픽셀 쉐이더] 소스 코드 파일을 [빌드에서 제외]할 수 [있다].
:: [Visual Studio]에서 컴파일 : [프로젝트 빌드]에서 컴파일시 [정점 쉐이더]와 [픽셀 쉐이더]를 [다른 파일]로 작성해야 한다.
:: 또한 [출력 파일] (컴파일된 쉐이드 코드)의 [위치를 설정]해야 한다.

# [4차시]

Direct3D 리소스
:: 정점 데이터, 쉐이더 데이터, 텍스쳐 등을 포함
:: [효율적으로 참조]할 수 있는 [메모리 영역]에 저장되어야 한다. 즉 [GPU]가 [효율적으로 읽고 쓰기] 가능해야 한다.
:: [CPU, GPU]가 리소스에 [접근할 수 있는 여부]를 [지정할 수 있다].
:: [응용 프로그램]에서 [비디오 메모리]의 내용을 읽는 것은 [매우 느리다].

파이프라인과 리소스
:: 응용 프로그램 : [파이프라인] 구성, [리소스 데이터] 준비
:: 쉐이더 프로그램 : [변환 처리], [픽셀 색상] 결정

입력 조립 단계 준비
:: [입력 버퍼 객체] 생성 -> 입력 버퍼에 대한 [뷰] 생성 -> [입력 레이아웃] 생성
-> [입력 버퍼]와 [입력 레이아웃]을 [파이프라인 상태]에 연결
-> [입력 버퍼]를 [입력 조립 단계]에 연결
-> [그리기 함수]를 [호출]

리소스 갱신
:: 리소스(서브 리소스)에 대한 [CPU 포인터]를 [반환] (다중 쓰레드 안전)
:: 소스 또는 목표 리소스의 [유형과 크기]가 [같아야] 한다.

리소스 생성
:: 정점 버퍼 생성 및 갱신

입력 레이아웃
:: [입력 조립기] 단계에 [연결되는] [입력 버퍼]의 [구조]
:: [정점 데이터 구조] 또는 [인스턴스 데이터 구조]
:: [정점 쉐이더]의 [입력 시그니쳐]와 일치해야 한다.
:: [입력 버퍼]의 [모든 원소들]은 [같은 자료형]을 가져야 한다.
:: 하나 또는 여러 개의 [버퍼]로 표현 및 조립

# [5차시]

프리미티브 유형
:: [파이프라인] (입력 조립기)이 [정점 버퍼]의 [데이터를 해석]하는 방법
:: _POINTLIST : 점 리스트. n개의 점 즉 [n개]의 정점
:: _LINELIST : 선 리스트. n개의 선분 즉 [2n개]의 정점
:: _LINESTRIP : 선 스트립. 선분의 마지막 정점이 다음 선분의 시작점 즉 [n+1개]의 정점
:: _TRIANGLELIST : 삼각형 리스트. n개의 삼각형을 연결 즉 [3n개]의 정점
:: _TRIANGLESTRIP : 삼각형 스트림. 마지막 2개의 정점과 그 다음 정점을 연결 즉 [n+2개]의 정점
:: [TRIANGLELIST]에서 [정점이 반복]되는 문제 발생

정점 버퍼 뷰 생성 / 인덱스 버퍼 뷰 생성 
:: [서술자]와 [서술자 힙]이 필요없음

# [6차시]

루트 시그너쳐
:: 루트 상수 : 매개변수가 [32비트 상수]를 포함, [쉐이더 변수]에 [값을 전달], [서술자 힙 X]
:: 루트 서술자 : 매개변수가 [내부 서술자]를 포함, [서술자 힙 X]
:: 서술자 테이블 : [서술자 힙]에 간접 접근하므로 [시간이 걸린다].
:: ID3D12RootSigniture 인터페이스
:: [루트 상수]로 [매핑]되는 [상수 버퍼]에는 [배열]을 [사용할 수 없다].

상수 버퍼 생성
:: [여러 쉐이더 상수]들의 [그룹]을 [동시에 갱신] 가능한 버퍼
:: [256바이트의 배수] 크기여야 함
:: [응용 프로그램]에서 변경하기 위한 용도로 생성함

# [7, 8차시]

루트 시그너쳐
:: 실수는 [루트 시그너쳐] 테이블을 [함수 호출]시 [스택]처럼 사용
:: 값을 [저장하기 위한 리소스]가 [필요 없음] 즉 [빠르게] [쉐이더 변수]의 [값]을 [전달]
:: [루트 시그너쳐] 테이블 원소의 [값]은 [리소스]의 [GPU 주소]이다.
:: [리소스]에 [쉐이더 변수]의 [값]을 저장한다.

루트 시그너쳐 [서술자 핸들] -> 서술자 힙 [서술자] -> 16개 실수

상수 버퍼 뷰 생성 및 사용
:: [생성]하는 것은 [응용 프로그램 (CPU)]
:: [사용]하는 것은 [쉐이더 프로그램 (GPU)]
:: [상수 버퍼]의 [일부 영역]에 [상수 버퍼 뷰]를 생성

서술자 힙 
:: 사용 전에 [디바이스] (파이프라인)에 [연결]되어야 함
:: [같은 유형]의 서술자 힙은 [한 번에 하나만] 설정할 수 있다.
:: [서술자 힙 배열]의 각 원소 (서술자 힙) 유형은 [서로 달라야 한다].

상수 버퍼의 갱신
:: [명령 리스트]는 [즉시 실행]되는 것이 [아니다].
:: 반면 [memcpy()]는 [즉시 실행]된다.

루트 시그너쳐 생성
:: [텍스쳐 (셰이더 리소스 뷰) 리소스 파라미터]는 반드시 [서술자 테이블]을 사용하여 [생성]

-----<계층구조의 표현과 애니메이션>-----

프레임 계층 구조
:: 단일 메쉬 / 다중 메쉬
:: 다중 메쉬 : [공간적 계층 구조] 또는 [프레임 계층 구조]
:: 참조 프레임 : [방향을 가진 점]을 표현하는 방식. [다른 참조 프레임]으로 [상대적인] 개념을 표현할 수 있다.

모델의 표현
:: 계층 구조 : 부모-자식관계 / 트리 / 노드
:: 노드 : [행렬] + [메쉬] +[자식에 대한 포인터]들
:: 각 노드는 [하나의 (참조)프레임]을 나타내며 필요한 데이터를 추가로 가질 수 있다.
:: 각 프레임은 [변환 행렬]을 통해 [공간적 계층 구조]를 나타낸다.
:: 모든 트리는 이진 트리로 표현 가능
:: 어떤 프레임의 [변환 행렬] 변화는 [자손 프레임]에 [영향]을 준다.

계층 구조의 프레임 렌더링
:: [변환]은 일반적으로 [SRT] (스케일 -> 회전 -> 이동)의 순서를 따른다.
:: [회전 변환]은 [로컬 좌표계]에서 수행되어야 한다.

-----<실외 지형>-----

실외 지형
:: 실외 지형을 위한 [메쉬] - 격자 정점
:: 크기 : width (x축) * length (z축)
:: 높이 : y = f (x, z) - 해당 좌표에서의 함수 결과
:: 높이 맵 : [각 픽셀]에서 [지형의 높이]를 나타내는 2차원 이미지
:: 해상도 : 픽셀 사이의 거리
:: 픽셀 사이의 점은 [인접한 픽셀들]에서 [근사] 계산
:: 실외 지형이 너무 [넓은 경우] [공간 분할]로 각 [분할된 공간]에 대하여 연산

높이와 법선 벡터
:: [높이 맵]의 [픽셀 값]을 사용하여 [지형의 높이] 계산 및 보간
:: [높이 맵]의 [픽셀 값]을 사용하여 [지형의 법선 벡터] 계산

-----<카메라 및 카메라 처리 기법>-----

1인칭 카메라 : 플레이어 메쉬 바로 위에
:: y축, 또는 z축(기울임) 기준으로 회전

3인칭 카메라 : 플레이어 메쉬에서 떨어진 위치에
:: y축 회전 : 플레이어를 중심으로 하여 회전

절두체 컬링 (Frustrum Culling)
:: [절두체 안 포함] 여부를 확인하려면 [6면]의 [방정식]을 알아야 한다.
:: [원근 투영 변환 행렬]하여 [절두체]를 직육면체로 바꾸어 계산한다.
:: [카메라 변환 행렬]과 [원근 투영 변환 행렬]을 곱하여 [월드 좌표계 컬링]으로 한다.
:: 객체의 [바운딩 박스]를 만들어 [절두체에 포함되는지] 판단한다.

-----<조명 및 조명 처리>-----

# [1차시]

정점의 조명 계산
:: 주변 광원 색상 (Ambient Color) + 확산 광원 색상 (Diffuse Light) + 스펙큘러 색상 (Specular Light) + 점 자체 발산 색상 (Emissive Light)
:: 주변 광원 색상 : 재질 광원 반사 색상, 전역 주변 광원 색상, 점에 영향을 주는 광원의 주변 광원 색상
:: 확산 광원 색상 : 재질 확산 반사 색상, 입사광 방향 벡터, 점에 영향을 주는 광원의 확산 광원 색상, 점의 법선 벡터
:: 스펙큘러 색상 : 재질 스펙큘러 반사 색상, 점에 영향을 주는 스펙큘러 광원, 점의 법선 벡터, 재질의 스펙큘러 파워, 중간 벡터
:: 점 자체 발산 색상

정점의 법선 벡터
:: 정점을 [포함하는] [모든 삼각형]의 [법선 벡터]의 [평균]
:: [정점 변환]시 [법선 벡터도 변환]
:: [접선 벡터]와 [법선 벡터]는 서로 수직
:: [법선 벡터]를 [단위 벡터]로 변환해야 한다.

점 조명
:: 감쇠 : [거리에 비례]하여 [빛의 양]이 [감소]한다.
:: 점 조명으로부터의 거리가 일정 거리를 넘어가면 영향을 받지 않는다.

스팟 조명
:: [일정 거리까지]는 [빛의 양]이 [동일]하다.
:: 감쇠 : 바깥에서는 [거리에 비례]하여 [빛의 양]이 [감소]한다.

방향성 조명
:: [한 방향]으로 [평행한 빛]을 낸다.
:: [거리]에 따른 [감쇠]가 [일어나지 않는다].

재질 
:: 정점(픽셀)이 조명을 어떻게 [반사 및 흡수]하는지 나타낸다.
:: 발광 조명 : 재질(점) [자체가 빛을 발산]하는 경우 - [다른 점]에는 [영향을 주지 않는다].

조명 시스템 : 여러 조명에 대한 효율적 처리